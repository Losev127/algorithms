<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сортировка массива</title>
</head>

<body>
    <h1>Сортировка массива</h1>
    <h3>Создание массива</h3>
    <label for="arraySize">Введите размер массива: </label>
    <input type="number" id="arraySize" placeholder="Размер массива">
    <button onclick="createRandomArray()">Создать массив</button>

    <div id="result"></div>
    <hr>
    <h3>Сортировка массива</h3>
    <button id="duplicateArrayBtn">Дублировать массив</button>
    <label for="sortAlgorithm">Выбор алгоритма сортировки:</label>
    <select id="sortAlgorithm">
        <option value="insertionSort">Сортировка вставками</option>
        <option value="selectionSort">Сортировка выбором</option>
        <option value="mergeSort">Сортировка слиянием</option>
        <option value="quickSort">Быстрая сортировка</option>
    </select>
    <button id="sortArrayBtn">Сортировать</button>
    <hr>
    <h3>Время выполнения операции (мс):</h3>
    <div id="operationTime"></div>
    <h3>Отсортированный массив:</h3>
    <div id="resultsortedArray"></div>

    <script>
        let array = [];

        function createRandomArray() {
            let size = document.getElementById('arraySize').value;
            array = [];
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * 100)); // Генерация случайных чисел от 0 до 99
            }
            document.getElementById('result').innerText = `Создан случайный массив: ${array}`;
        }



        // Этот фрагмент кода отвечает за выполнение дублирования массива array при нажатии на кнопку с идентификатором duplicateArrayBtn.
        // 1. document.getElementById('duplicateArrayBtn'): Это часть кода ищет элемент в документе HTML с идентификатором duplicateArrayBtn,
        // который, вероятно, является кнопкой для дублирования массива.

        // 2. addEventListener('click', function() { ... }): Этот код добавляет обработчик события "click" к найденному элементу. То есть,
        // когда происходит клик по кнопке, будет выполнена функция, переданная вторым аргументом.

        // 3. duplicateArray = array.slice();: Внутри функции, связанной с событием "click", выполняется дублирование массива array с
        // помощью метода slice(). Метод slice() создает новый массив, содержащий копию элементов из исходного массива. Таким образом,
        // после выполнения этой строки duplicateArray будет содержать копию всех элементов из массива array.

        // 4. alert("Массив был успешно дублирован");: После выполнения дублирования массива будет показано всплывающее
        // уведомление с сообщением "Массив был успешно дублирован".

        // Таким образом, данный фрагмент кода отвечает за дублирование массива array и уведомление пользователя об успешном
        // выполнении этой операции при нажатии на кнопку с идентификатором duplicateArrayBtn.

        document.getElementById('duplicateArrayBtn').addEventListener('click', function () {
            duplicateArray = array.slice(); // Дублирование массива с помощью метода slice
            alert("Массив был успешно дублирован");
        });



        function insertionSort(arr) {
            // Это объявление функции с именем insertionSort, которая принимает один аргумент arr, представляющий массив, который нужно отсортировать.

            const arrayCopy = [...arr];
            // В этой строке создается копия исходного массива arr с помощью оператора spread [...arr].
            // Это позволяет функции сортировки работать с копией массива, чтобы не изменять исходный массив.
            // Однако в данном случае копия массива не используется внутри функции для сортировки,
            // поэтому этот код может быть удален.

            for (let i = 1; i < arr.length; i++) {
                // Этот цикл проходит по всем элементам массива, начиная со второго элемента (индекс 1).

                let current = arr[i];
                // В этой строке переменной current присваивается значение текущего элемента массива arr (элемент с индексом i).

                let j = i - 1;
                // Переменная j инициализируется индексом, предшествующим текущему элементу.

                while (j >= 0 && arr[j] > current) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                // Этот цикл выполняется, пока индекс j больше или равен нулю и значение элемента массива с
                // индексом j больше, чем current. Это позволяет перемещать элементы влево,
                // чтобы вставить current в правильное место.

                arr[j + 1] = current;
                // После завершения внутреннего цикла, current вставляется на правильную позицию в массиве.
            }
            document.getElementById('resultsortedArray').innerText = `Результат сортировки вставками: ${arr}`;
            // В последней строке кода результат сортировки вставками присваивается внутреннему тексту элемента с идентификатором resultsortedArray.
        }



        function selectionSort(arr) {
            // Это объявление функции с именем selectionSort, которая принимает один аргумент arr, представляющий массив, который нужно отсортировать.

            const arrayCopy = [...arr];
            // В этой строке создается копия исходного массива arr с помощью оператора spread [...arr].
            // Это позволяет функции сортировки работать с копией массива, чтобы не изменять исходный массив.
            // В данной функции копия массива не используется, поэтому этот код может быть удален.

            const len = arr.length;
            // В этой строке определяется длина массива, которая будет использоваться в циклах.


            for (let i = 0; i < len - 1; i++) {
                // Этот цикл проходит по всем элементам массива, за исключением последнего.
                let minIndex = i;
                // В этой строке переменной minIndex присваивается значение индекса текущего элемента, предполагаемого как минимальный.
                for (let j = i + 1; j < len; j++) {
                    // Вложенный цикл проходит по оставшимся элементам массива, начиная с элемента, следующего за текущим.
                    if (arr[j] < arr[minIndex]) {
                        minIndex = j;
                    }
                    // В этом условии проверяется, является ли значение элемента с индексом j меньшим, чем значение элемента с индексом minIndex.
                    // Если условие выполняется, то minIndex присваивается значение j, что означает, что найден новый минимальный элемент.
                }
                if (minIndex !== i) {
                    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // Обмен элементов местами
                }
                // После завершения вложенного цикла проверяется, был ли найден элемент, меньший чем текущий минимальный элемент.
                // Если да, то значения текущего элемента и минимального элемента меняются местами с помощью деструктуризации массива.
            }

            document.getElementById('resultsortedArray').innerText = `Результат сортировки выбором: ${arr}`;
            // результат сортировки выбором присваивается внутреннему тексту элемента с идентификатором resultsortedArray.
        }



        function mergeSort(arr) {
            // Это объявление функции с именем mergeSort, которая принимает один аргумент arr, представляющий массив, который нужно отсортировать.

            const arrayCopy = [...arr];
            // В этой строке создается копия исходного массива arr с помощью оператора spread [...arr]. В данной функции копия массива не используется, поэтому этот код может быть удален.


            if (arr.length <= 1) {
                document.getElementById('resultsortedArray').innerText = `Результат сортировки слиянием: ${arr}`;
                return arr;
            }
            // Это базовый случай рекурсии, который проверяет, если длина массива меньше или равна 1, то массив уже отсортирован,
            // и его значение выводится в элемент с идентификатором resultsortedArray, и затем возвращается из функции.


            const middle = Math.floor(arr.length / 2);
            // В этой строке определяется индекс среднего элемента исходного массива.

            const left = arr.slice(0, middle);
            // Здесь создается подмассив left, содержащий элементы исходного массива с индексами от 0 до middle (не включая middle).

            const right = arr.slice(middle);
            // Здесь создается подмассив right, содержащий элементы исходного массива с индексами от middle до конца.

            const result = merge(mergeSort(left), mergeSort(right));
            // Рекурсивно вызываются функции mergeSort для подмассивов left и right, и их результаты объединяются с помощью функции merge.
            // Результат сортировки слиянием присваивается переменной result.

            document.getElementById('resultsortedArray').innerText = `Результат сортировки слиянием: ${result}`;
            // результат сортировки слиянием присваивается внутреннему тексту элемента с идентификатором resultsortedArray.

            return result;
            // Возвращается отсортированный массив result.
        }



        function merge(left, right) {
            // Это объявление функции с именем merge, которая принимает два аргумента left и right, представляющие два отсортированных массива, которые нужно объединить.

            let result = [];
            // В этой строке создается пустой массив result, который будет содержать отсортированный результат объединения left и right.

            let leftIndex = 0;
            let rightIndex = 0;
            // Эти строки инициализируют переменные leftIndex и rightIndex, которые будут использоваться для прохода по массивам left и right соответственно.

            while (leftIndex < left.length && rightIndex < right.length) {
                // Этот цикл выполняется, пока не будет достигнут конец хотя бы одного из массивов left или right.
                if (left[leftIndex] < right[rightIndex]) {
                    result.push(left[leftIndex]);
                    leftIndex++;
                } else {
                    result.push(right[rightIndex]);
                    rightIndex++;
                }
            }
            // В этом условии проверяется, какой из элементов, находящихся под текущими индексами leftIndex и rightIndex, меньше.
            // Меньший элемент добавляется в массив result, и соответствующий индекс увеличивается.

            const resultArray = result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
            // После завершения цикла создается новый массив resultArray, объединяющий элементы, оставшиеся в массивах left и right.

            return resultArray;
            // Возвращается новый массив resultArray, содержащий отсортированное объединение массивов left и right.
        }



        function quickSort(arr, left = 0, right = arr.length - 1) {
            // Это объявление функции с именем quickSort, которая принимает три аргумента: массив arr,
            // левую границу left (по умолчанию 0) и правую границу right (по умолчанию arr.length - 1).

            const arrayCopy = [...arr];
            // В этой строке создается копия исходного массива arr с помощью оператора spread [...arr].
            // В данной функции копия массива не используется, поэтому этот код может быть удален.

            if (arr.length > 1) {
                // Этот блок условия проверяет, имеет ли массив больше одного элемента, чтобы определить, нужно ли выполнять сортировку.

                let index = partition(arr, left, right);
                // Здесь вызывается функция partition для разделения массива на две части и получения индекса опорного элемента.


                if (left < index - 1) {
                    quickSort(arr, left, index - 1);
                }
                // В этом условии проверяется, нужно ли выполнить быструю сортировку для левой части массива до опорного элемента.


                if (index < right) {
                    quickSort(arr, index, right);
                }
                // В этом условии проверяется, нужно ли выполнить быструю сортировку для правой части массива после опорного элемента.

            }
            document.getElementById('resultsortedArray').innerText = `Результат быстрой сортировки: ${arr}`;
            // результат быстрой сортировки присваивается внутреннему тексту элемента с идентификатором resultsortedArray.
        }

        function partition(arr, left, right) {
            // Это объявление функции с именем partition, которая принимает три аргумента: массив arr, левую границу left и правую границу right.

            const pivot = arr[Math.floor((right + left) / 2)];
            // Здесь выбирается опорный элемент, который является средним элементом между левой и правой границами массива.

            let i = left;
            let j = right;
            // Эти строки инициализируют переменные i и j, которые будут использоваться для перемещения по массиву.

            while (i <= j) {
                // Этот цикл выполняется, пока индекс i меньше или равен индексу j.

                while (arr[i] < pivot) {
                    i++;
                }
                // Внутренний цикл проверяет элементы слева от опорного элемента и увеличивает индекс i, пока значения элементов меньше опорного.

                while (arr[j] > pivot) {
                    j--;
                }
                // Второй внутренний цикл проверяет элементы справа от опорного элемента и уменьшает индекс j, пока значения элементов больше опорного.

                if (i <= j) {
                    [arr[i], arr[j]] = [arr[j], arr[i]]; // Обмен элементов местами
                    i++;
                    j--;
                }
            }
            // Если индекс i по-прежнему меньше или равен индексу j, то значения элементов с индексами i и j
            // меняются местами с помощью деструктуризации массива,
            // затем индексы i и j увеличиваются и уменьшаются соответственно.

            return i;
            // В конце функции возвращается индекс i, который будет использоваться для разделения массива на две части.
        }


        document.getElementById('sortArrayBtn').addEventListener('click', function () {
            // Этот код добавляет обработчик события нажатия кнопки с идентификатором "sortArrayBtn". Когда кнопка будет нажата, будет выполнена указанная функция.

            let sortAlgorithm = document.getElementById('sortAlgorithm').value;
            // В этой строке кода извлекается значение выбранного алгоритма сортировки из элемента с идентификатором "sortAlgorithm" и сохраняется в переменной sortAlgorithm.

            let startTime, endTime;
            // Эти переменные будут использоваться для отслеживания времени начала и окончания выполнения сортировки.


            let arrToSort = duplicateArray.slice(); // Использование дублированного массива для сортировки
            // Здесь создается копия исходного массива duplicateArray с помощью метода slice().
            // Это делается для того, чтобы использовать копию массива для сортировки, чтобы не изменять исходный массив.




            // Этот блок кода проверяет значение переменной sortAlgorithm и выполняет соответствующий блок кода в зависимости от выбранного алгоритма сортировки.

            // Внутри каждого случая (case) вызывается соответствующая функция сортировки (insertionSort, selectionSort, mergeSort, quickSort).
            // Перед выполнением сортировки фиксируется время начала выполнения, а после выполнения - время окончания.

            // В случае, если выбран неизвестный алгоритм сортировки, вызывается сообщение об ошибке с помощью alert.

            switch (sortAlgorithm) {
                case 'insertionSort':
                    startTime = performance.now();
                    insertionSort(arrToSort);
                    endTime = performance.now();
                    break;
                case 'selectionSort':
                    startTime = performance.now();
                    selectionSort(arrToSort);
                    endTime = performance.now();
                    break;
                case 'mergeSort':
                    startTime = performance.now();
                    mergeSort(arrToSort);
                    endTime = performance.now();
                    break;
                case 'quickSort':
                    startTime = performance.now();
                    quickSort(arrToSort, 0, arrToSort.length - 1);
                    endTime = performance.now();
                    break;
                default:
                    alert('Неизвестный алгоритм сортировки');
            }

            let operationTime = endTime - startTime;
            document.getElementById('operationTime').innerText = `Время выполнения операции (${sortAlgorithm}): ${operationTime} мс`;
        });
    </script>
</body>

</html>