document.addEventListener('DOMContentLoaded', function() {
    const screen = document.querySelector('.screen span');
    // Эта строка использует метод document.querySelector для поиска элемента на веб-странице с классом "screen",
    // а затем находит вложенный элемент span. Найденный элемент присваивается переменной screen для последующего использования.
    
    const timeElement = document.getElementById('time');
    // Эта строка использует метод document.getElementById для поиска элемента на веб-странице с идентификатором "time"
    // и присваивает найденный элемент переменной timeElement.

    const buttons = document.querySelectorAll('.key');
    // Эта строка использует метод document.querySelectorAll для поиска всех элементов на веб-странице с классом "key" и присваивает
    // найденные элементы переменной buttons. querySelectorAll возвращает коллекцию (NodeList) элементов, соответствующих заданному CSS-селектору.
    
    let expression = '';
    // Это объявление переменной expression и инициализация ее значения пустой строкой.
    // Переменная будет использоваться для хранения математического выражения, введенного пользователем в калькулятор.


    buttons.forEach(button => {
        // Этот код использует метод forEach для перебора всех элементов коллекции buttons (кнопок калькулятора) и
        // применяет указанную функцию к каждому из них.

        button.addEventListener('click', function() {
            // Здесь мы добавляем обработчик события "click" к каждой кнопке. Это означает, что
            // указанная функция будет выполняться при каждом клике на кнопку.

            const value = this.textContent;
            // Мы получаем текстовое содержимое кнопки, на которую было совершено нажатие, и сохраняем его в переменную value.

            if (value === 'C') {
                expression = '';
                // десь мы проверяем, была ли нажата кнопка "C" (очистка). Если да, то мы очищаем переменную expression.


            } else if (value === '=') {
                const startTime = performance.now();
                try {
                    const result = evaluateExpression(expression);
                    expression = result;
                } catch (error) {
                    expression = 'Error';
                }
                const endTime = performance.now();
                const timeTaken = endTime - startTime;
                timeElement.textContent = `Затраченное время: ${timeTaken.toFixed(2)} ms`;
                // Если нажата кнопка "=", то мы начинаем процесс вычисления выражения.
                // Мы измеряем время начала вычислений с помощью performance.now(),
                // затем вызываем функцию evaluateExpression(expression) для вычисления результата,
                // измеряем время завершения вычислений, вычисляем разницу времени и выводим ее в элемент timeElement.


            } else {
                expression += value;
            }
            // Если нажата любая другая кнопка, ее значение добавляется к переменной expression, представляющей математическое выражение.


            screen.textContent = expression;
            // Мы обновляем содержимое элемента screen (дисплей калькулятора) с помощью переменной expression,
            // чтобы отобразить текущее математическое выражение.
        });
    });

    function evaluateExpression(expression) {
        const tokens = expression.match(/(\d+(\.\d+)?|\+|\-|\*|\/|\^|\(|\)|√|e|π|sin|cos|tan|log|exp)/g);
        // В этой строке мы используем метод match для поиска всех токенов (чисел, операторов и функций) в строке expression.
        // Регулярное выражение /(\d+(\.\d+)?|\+|\-|\*|\/|\^|\(|\)|√|e|π|sin|cos|tan|log|exp)/g используется для этой цели.

        const stack = [];
        // Здесь мы создаем пустой массив stack, который будет использоваться для хранения операторов и функций во время обработки токенов.

        const output = [];
        // Мы создаем пустой массив output, который будет использоваться для хранения токенов в порядке, подходящем для вычислений.


        const precedence = {
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3,
            '√': 4,
            'sin': 5,
            'cos': 5,
            'tan': 5,
            'log': 5,
            'exp': 5
        };
        // Здесь мы создаем объект precedence, который содержит информацию о приоритете операторов и функций.
        // Ключи объекта соответствуют операторам и функциям, а значения - их приоритету.
        // Это будет использоваться при преобразовании инфиксного выражения в постфиксное выражение.




        // Этот фрагмент кода отвечает за преобразование массива токенов в постфиксное выражение,
        // которое затем будет использоваться для вычисления математического выражения. 

        tokens.forEach(token => {
        // Здесь мы используем метод forEach для перебора всех токенов в массиве tokens и применяем указанную функцию к каждому токену.


            if (isNumeric(token)) {
                output.push(token);
                // Если текущий токен является числом, мы добавляем его в массив output, который представляет собой постфиксное выражение.


            } else if (token === 'e') {
                output.push(Math.E);
                // Если текущий токен представляет константу "e", мы добавляем значение числа Эйлера (Math.E) в массив output.


            } else if (token === 'π') {
                output.push(Math.PI);
                // Если текущий токен представляет константу "π", мы добавляем значение числа Пи (Math.PI) в массив output.


            } else if (token === '(') {
                stack.push(token);
                // Если текущий токен является открывающей скобкой, мы помещаем его в стек stack.


            } else if (token === ')') {
                while (stack.length > 0 && stack[stack.length - 1] !== '(') {
                    output.push(stack.pop());
                }
                stack.pop();
                // Если текущий токен является закрывающей скобкой,
                // мы извлекаем операторы из стека stack и добавляем их в массив output,
                // пока не встретим открывающую скобку.


            } else {
                while (stack.length > 0 && precedence[stack[stack.length - 1]] >= precedence[token]) {
                    output.push(stack.pop());
                }
                stack.push(token);
            }
        });
        // В противном случае, если текущий токен представляет оператор или функцию, мы проверяем их
        // приоритет с помощью объекта precedence и соответственно добавляем их в стек stack или в массив output.


        while (stack.length > 0) {
            output.push(stack.pop());
        }
        // После обработки всех токенов, мы извлекаем оставшиеся операторы из стека stack и добавляем их в массив output.



        // фрагмент кода отвечает за вычисление результата математического выражения, представленного в виде постфиксного выражения. 

        const resultStack = [];
        // Здесь мы создаем пустой стек resultStack, который будет использоваться для выполнения операций вычисления.

        output.forEach(token => {
            // Мы используем метод forEach для перебора всех токенов в массиве output и применяем указанную функцию к каждому токену.

            if (isNumeric(token)) {
                resultStack.push(parseFloat(token));
                // Если текущий токен является числом, мы преобразуем его в число с плавающей запятой и помещаем в стек resultStack.

            } else if (token === '√') {
                const operand = resultStack.pop();
                resultStack.push(Math.sqrt(operand));
                // Если текущий токен представляет операцию извлечения квадратного корня, мы извлекаем операнд из стека,
                // вычисляем квадратный корень и помещаем результат обратно в стек.

            } else if (token === 'sin') {
                resultStack.push(Math.sin(resultStack.pop()));
                // Если текущий токен представляет операцию нахождения синуса, мы извлекаем операнд из стека,
                // вычисляем синус и помещаем результат обратно в стек.

            } else if (token === 'cos') {
                resultStack.push(Math.cos(resultStack.pop()));
                // Аналогично для операций нахождения косинуса и тангенса.

            } else if (token === 'tan') {
                resultStack.push(Math.tan(resultStack.pop()));
                // Аналогично для операций нахождения косинуса и тангенса.

            } else if (token === 'log') {
                const base = resultStack.pop();
                const value = resultStack.pop();
                resultStack.push(Math.log(value) / Math.log(base));
                // Если текущий токен представляет операцию логарифма, мы извлекаем базу и значение из стека,
                // вычисляем логарифм с указанной базой и помещаем результат обратно в стек.

            } else if (token === 'exp') {
                resultStack.push(Math.exp(resultStack.pop()));
                // Если текущий токен представляет операцию экспоненты, мы извлекаем операнд из стека,
                // вычисляем экспоненту и помещаем результат обратно в стек.

            } else {
                const b = resultStack.pop();
                const a = resultStack.pop();
                if (token === '+') {
                    resultStack.push(a + b);
                } else if (token === '-') {
                    resultStack.push(a - b);
                } else if (token === '*') {
                    resultStack.push(a * b);
                } else if (token === '/') {
                    resultStack.push(a / b);
                } else if (token === '^') {
                    resultStack.push(Math.pow(a, b));
                }
            }
        });
            // В противном случае, если текущий токен представляет операцию сложения, вычитания, умножения,
            // деления или возведения в степень, мы извлекаем соответствующее количество операндов из стека,
            // выполняем указанную операцию и помещаем результат обратно в стек.


        if (resultStack.length !== 1) {
            throw new Error('Invalid expression');
        }
        // После завершения вычислений, мы проверяем, остался ли ровно один результат в стеке resultStack.
        // Если это не так, мы выбрасываем ошибку, так как это указывает на неверное выражение.

        return resultStack[0].toFixed(2);
    }
    // Мы возвращаем результат вычислений, округленный до двух знаков после запятой.


    // Эта функция isNumeric предназначена для проверки, является ли переданное значение числом

    function isNumeric(value) {
        // Здесь мы объявляем функцию isNumeric, которая принимает один аргумент value, который мы будем проверять на числовой тип.

        return !isNaN(value) && isFinite(value);
//         В этой строке кода используется логическое "И" для проверки двух условий:
//    - !isNaN(value) - Это проверка на то, является ли значение числом с плавающей запятой. Функция isNaN возвращает true,
//    если переданное значение не является числом. Путем добавления отрицания ! мы получаем true, если значение является числом.
//    - isFinite(value) - Это проверка на конечность числа. Функция isFinite возвращает true, если значение является конечным числом.
//    Это необходимо для исключения значений Infinity и -Infinity.

//     Таким образом, если оба условия выполняются, функция isNumeric возвращает true, указывая на то, что переданное значение является числом.
//     Если хотя бы одно из условий не выполняется, функция вернет false, указывая на то, что переданное значение не является числом.
    }
});